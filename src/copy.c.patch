--- /home/ijntema/truenas/programming/securecopy/core-utils-based/V9.7.0/coreutils-9.7/src/copy.c.org	2025-08-14 14:54:55.275265300 +0200
+++ /home/ijntema/truenas/programming/securecopy/core-utils-based/V9.7.0/coreutils-9.7/src/copy.c	2025-08-14 14:54:55.275035200 +0200
@@ -55,20 +55,22 @@
 #include "same.h"
 #include "savedir.h"
 #include "stat-size.h"
 #include "stat-time.h"
 #include "utimecmp.h"
 #include "utimens.h"
 #include "write-any-file.h"
 #include "areadlink.h"
 #include "yesno.h"
 #include "selinux.h"
+/* HIJN */
+#include "crcsum.h"
 
 #ifndef USE_XATTR
 # define USE_XATTR false
 #endif
 
 #if USE_XATTR
 # include <attr/error_context.h>
 # include <attr/libattr.h>
 # include <stdarg.h>
 #endif
@@ -1241,28 +1243,116 @@
   int dest_desc;
   int dest_errno;
   int source_desc;
   mode_t extra_permissions;
   struct stat sb;
   struct stat src_open_sb;
   union scan_inference scan_inference;
   bool return_val = true;
   bool data_copy_required = x->data_copy_required;
   bool preserve_xattr = USE_XATTR & x->preserve_xattr;
+  /* HIJN */
+  t_crc64 crc_src = 0;
 
   copy_debug.offload = COPY_DEBUG_UNKNOWN;
   copy_debug.reflink = x->reflink_mode ? COPY_DEBUG_UNKNOWN : COPY_DEBUG_NO;
   copy_debug.sparse_detection = COPY_DEBUG_UNKNOWN;
 
   source_desc = open (src_name,
                       (O_RDONLY | O_BINARY
                        | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+
+/* HIJN */
+// Checksum
+
+  // Verbose print
+  if  ( ( (x->crc) || (x->crc_with_xattr) ) && (x->verbose) )
+  {
+    printf("SOURCE: [%s]\n", src_name);	    
+  }
+  
+  if (x->crc)
+  {
+	// flag: -c; calculate checksum w/o xattr
+    crc_src = CalculateCRC64(src_name);
+	
+    if (x->verbose)
+    {
+      char* szCRC;
+      int   ret;
+      ret = asprintf(&szCRC, "%016llX", crc_src);
+
+      if ( ret != -1)
+      {
+        printf("SOURCE: CRC [%s] is freshly calculated\n", szCRC);
+      }
+    }
+  }
+
+  if (x->crc_with_xattr)
+  {
+	// flag: -cx; use xattr (if possible)
+	
+	// Check if xattr CRC is fresh
+	// Update CRC in xattr when current one is stale or not present
+    if ( !IsFreshCRC(src_name) ) 
+    {
+	  // CRC is stale or non-existent
+      // suppress printing errors by bPutCRC when writing CRC in source xattr, 
+	  // as file can be read-only or filesystem might not support xattr
+	  // which is a legitimate use case.
+      bool bError = false;
+
+      // Get new CRC and store in xattr
+	  crc_src = 0;
+      if ( !bPutCRC(src_name, &crc_src, bError) )
+      {
+        // bPutCRC was not successfull
+		// Don't print as error, but as warning as source file 
+		// can be a read only file or file system does not support
+        printStatus(src_name, "WARNING: FAILED to store CRC in xattr. File is read-only or filesystem does not support xattr?", YELLOW);
+      }
+      else if (x->verbose)
+      {
+		char* szCRC;
+        int   ret;
+        ret = asprintf(&szCRC, "%016llX", crc_src);
+
+		if ( ret != -1)
+		{
+		  textcolor(BRIGHT,YELLOW,BLACK);
+		  printf("SOURCE: CRC [%s] is stored in xattr\n", szCRC);
+		  RESET_TEXT();
+		}          
+      }
+    }
+	
+	// CRC is available in xattr and is fresh
+    else
+    {
+      crc_src = getCRC(src_name);
+	  
+	  if (x->verbose)
+      {
+		char* szCRC;
+        int   ret;
+        ret = asprintf(&szCRC, "%016llX", crc_src);  
+		  
+        textcolor(BRIGHT,YELLOW,BLACK);
+		printf("SOURCE: CRC [%s] is retrieved from xattr\n", szCRC);
+        RESET_TEXT();
+      }
+    }
+
+  }
+  /* END HIJN */
+
   if (source_desc < 0)
     {
       error (0, errno, _("cannot open %s for reading"), quoteaf (src_name));
       return false;
     }
 
   if (fstat (source_desc, &src_open_sb) != 0)
     {
       error (0, errno, _("cannot fstat %s"), quoteaf (src_name));
       return_val = false;
@@ -1712,20 +1802,172 @@
       error (0, errno, _("failed to close %s"), quoteaf (dst_name));
       return_val = false;
     }
 close_src_desc:
   if (close (source_desc) < 0)
     {
       error (0, errno, _("failed to close %s"), quoteaf (src_name));
       return_val = false;
     }
 
+  /* HIJN */
+  // Checksum
+  // Execute only if copy action itself is successfull
+  
+  // Verbose print
+  if (((x->crc) || (x->crc_with_xattr)) && (x->verbose))
+  {
+    printf("DESTINATION: [%s]\n", dst_name);	    
+  }
+  
+  if ( ( return_val != false ) && ( ( x->crc ) || (x->crc_with_xattr) ) )
+  {
+    t_crc64 crc_des = 0;
+
+    // ONLY for testing
+    //
+    // printf("WAIT\n");
+    // getchar();
+
+    // Calculate CRC of destination file
+    crc_des = CalculateCRC64(dst_name);
+	
+	if (x->verbose)
+	{
+	  char* szCRC;
+	  int   ret;
+	  ret = asprintf(&szCRC, "%016llX", crc_des);
+	  if ( ret != -1)
+	  {
+		printf("DESTINATION: CRC [%s] is freshly calculated\n", szCRC);
+	  }
+	}
+
+    // Compare CRC destination and source
+    if (crc_des != crc_src)
+    {
+	  // CRC destination <> source	
+      // But, we will do some extra checking before raising an error		
+		
+      if (!x->verbose)
+      {
+        printf("%s]\n", src_name);
+      }
+
+      // when using crc from stored xattr, it can happen that in very specific cases
+      // that src_file CRC is not flagged as stale, but file did change.
+      // Either by disk faults (file corruption --> error) 
+	  // or file has been changed w/o updating mtime (irritating, but file is not corrupt)
+      // Example: Office 2003 is known to update Excel files when reading, even when they are not explicitely saved
+      // Office 2003 does update an internal atime in the excel file w/o updating file's mtime
+	  // In case crc used from xattr and CRC src <> des, recalculate source CRC 
+      if (x->crc_with_xattr)
+      {
+        crc_src = CalculateCRC64(src_name);
+
+        // Initially, there was a crc mismatch based on stored crc in xattr. 
+		// We have re-calculated the source crc
+        if (crc_des == crc_src)
+        {
+			
+		  if (x->verbose)
+		  {
+		    char* szCRC;
+		    int   ret;
+		    ret = asprintf(&szCRC, "%016llX", crc_src);
+		    if ( ret != -1)
+		    {
+			  textcolor(BRIGHT,RED,BLACK);
+			  printf("SOURCE: CRC [%s] is freshly calculated\n", szCRC);
+		    }
+		  }
+				
+          textcolor(BRIGHT,YELLOW,BLACK);
+          printf("WARNING: CRC SOURCE == CRC DESTINATION (based on freshly calculated CRC's)\n");
+          printf("WARNING: But xattr CRC of SOURCE file does not match freshly calculated CRC of SOURCE file\n");
+		  printf("WARNING: SRC file is potentially corrupted OR changed w/o updating mtime, eg MS Excel is prone to this.\n");
+          RESET_TEXT();
+
+		  // As SOURCE = DESTINATION, we can set to success
+          // return_val = true; (not requires to set, as that is starting point, cp or mv itself is already successfull)
+        }
+        else
+		// Recalculating SOURCE CRC did not resolve mismatch in CRC
+        {
+	      textcolor(BRIGHT,RED,BLACK);
+          printf(":Checksum FAILED\n");
+		  
+          char* szCRC1;
+		  char* szCRC2;
+          int   ret1, ret2;
+		  ret1 = asprintf(&szCRC1, "%016llX", crc_src);
+          ret2 = asprintf(&szCRC2, "%016llX", crc_des);
+          if (( ret1 != -1) && ( ret2 != -1)) 
+          {
+            printf("SOURCE CRC [%s], DESTINATION CRC [%s]\n", szCRC1, szCRC2);
+          }		  
+		  RESET_TEXT();
+		  
+          return_val = false;
+        }
+      }
+      else
+	  // x->crc=true, nothing to be done, CRC error!
+      {
+	      textcolor(BRIGHT,RED,BLACK);
+          printf(":Checksum FAILED\n");
+		  
+          char* szCRC1;
+		  char* szCRC2;
+          int   ret1, ret2;
+		  ret1 = asprintf(&szCRC1, "%016llX", crc_src);
+          ret2 = asprintf(&szCRC2, "%016llX", crc_des);
+          if (( ret1 != -1) && ( ret2 != -1)) 
+          {
+            printf("SOURCE CRC [%s], DESTINATION CRC [%s]\n", szCRC1, szCRC2);
+          }		  
+		  RESET_TEXT();
+		  
+          return_val = false;
+      }
+    }
+    
+    // Check if CRC is stored in DESTINATION xattr (as SOURCE might be read only, or filesystem does not support xattr)
+    if ( return_val == true && x->crc_with_xattr )
+    {
+      // Check if DESTINATION has a CRC stored in xattr
+	  if ( !IsFreshCRC(dst_name) )
+      {
+        // Suppress errors writing CRC in DESTINATION xattr, as DESTINATION filesystem might not support xattr
+        bool bError = false;
+		
+        // CRC is not available in DESTINATION xattr
+		if ( !bPutCRC(dst_name, &crc_des, bError) )
+        {
+          if (x->verbose)
+          {
+            // as this is not a fatal error, mark it as yellow
+            printStatus(dst_name, "INFO: Cannot store/update DESTINATION CRC in xattr; xattr not supported on filesystem?", YELLOW);
+            RESET_TEXT();
+          }
+        }
+      }
+    }
+  }
+  
+  // Verbose print
+  if (((x->crc) || (x->crc_with_xattr)) && (x->verbose))
+  {
+    printf("\n");	    
+  }
+  /* END HIJN */
+
   /* Output debug info for data copying operations.  */
   if (x->debug)
     emit_debug (x);
 
   alignfree (buf);
   return return_val;
 }
 
 /* Return whether it's OK that two files are the "same" by some measure.
    The first file is SRC_NAME and has status SRC_SB.
