--- /home/ijntema/programming/securecopy/core-utils-based/V9.0.0/coreutils-9.0/src/copy.c.org	2021-11-14 12:33:01.327354098 +0100
+++ /home/ijntema/programming/securecopy/core-utils-based/V9.0.0/coreutils-9.0/src/copy.c	2021-11-14 12:33:01.331354029 +0100
@@ -58,20 +58,21 @@
 #include "savedir.h"
 #include "stat-size.h"
 #include "stat-time.h"
 #include "utimecmp.h"
 #include "utimens.h"
 #include "write-any-file.h"
 #include "areadlink.h"
 #include "yesno.h"
 #include "xstrtol.h"
 #include "selinux.h"
+#include "crcsum.h"
 
 #if USE_XATTR
 # include <attr/error_context.h>
 # include <attr/libattr.h>
 # include <stdarg.h>
 # include "verror.h"
 #endif
 
 #if HAVE_LINUX_FALLOC_H
 # include <linux/falloc.h>
@@ -1130,24 +1131,84 @@
   char *name_alloc = NULL;
   int dest_desc;
   int dest_errno;
   int source_desc;
   mode_t src_mode = src_sb->st_mode;
   struct stat sb;
   struct stat src_open_sb;
   union scan_inference scan_inference;
   bool return_val = true;
   bool data_copy_required = x->data_copy_required;
+  t_crc64 crc_src = 0;
 
   source_desc = open (src_name,
                       (O_RDONLY | O_BINARY
                        | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+
+  // Checksum
+  if (x->crc)
+  {
+    crc_src = CalculateCRC64(src_name);
+    if (x->verbose)
+    {
+      char* szCRC;
+      int   ret;
+      ret = asprintf(&szCRC, "%016llX", crc_src);
+
+      if ( ret != -1)
+      {
+        printf("[%s]", szCRC);
+      }
+    }
+  }
+
+  if (x->crc_with_xattr)
+  {
+    if ( !IsFreshCRC(src_name) ) // UPDATE CRC when stale
+    {
+      // suppress errors writing crc in source xattr, as file can be read only or filesystem might not support xattr
+      bool bError = false;
+
+      // CRC is stale & get new CRC
+      if ( !bPutCRC(src_name, &crc_src, bError) )
+      {
+        // Don't print an error, as source file can be a read only file, which is a legitimate use case
+        // printStatus(src_name, "FAILED to update CRC", RED);
+      }
+      else if (x->verbose)
+      {
+        textcolor(BRIGHT,YELLOW,BLACK);
+        printf("Updated CRC");
+        RESET_TEXT();
+      }
+    }
+    else
+    {
+      crc_src = getCRC(src_name);
+    }
+
+    if (x->verbose)
+    {
+      char* szCRC;
+      int   ret;
+      ret = asprintf(&szCRC, "%016llX", crc_src);
+
+      if ( ret != -1)
+      {
+        printf("[%s]", szCRC);
+      }
+    }
+  }
+
+
+
+
   if (source_desc < 0)
     {
       error (0, errno, _("cannot open %s for reading"), quoteaf (src_name));
       return false;
     }
 
   if (fstat (source_desc, &src_open_sb) != 0)
     {
       error (0, errno, _("cannot fstat %s"), quoteaf (src_name));
       return_val = false;
@@ -1495,20 +1556,117 @@
       error (0, errno, _("failed to close %s"), quoteaf (dst_name));
       return_val = false;
     }
 close_src_desc:
   if (close (source_desc) < 0)
     {
       error (0, errno, _("failed to close %s"), quoteaf (src_name));
       return_val = false;
     }
 
+  // Checksum
+  // only if copy itself is successfull
+  if (( return_val != false ) && ( ( x->crc ) || (x->crc_with_xattr) ))
+  {
+    t_crc64 crc_des = 0;
+
+    // ONLY for testing
+    //
+    // printf("WAIT\n");
+    // getchar();
+
+    crc_des = CalculateCRC64(dst_name);
+
+    if (crc_des != crc_src)
+    {
+      if (!x->verbose)
+      {
+        printf("%s ", src_name);
+      }
+      textcolor(BRIGHT,RED,BLACK);
+      if (x->verbose)
+      {
+        char* szCRC;
+        int   ret;
+        ret = asprintf(&szCRC, "%016llX", crc_des);
+        if ( ret != -1)
+        {
+          printf("[%s]", szCRC);
+        }
+      }
+
+      // when using crc from stored xattr, it can happen that in very specific cases
+      // that src_file CRC is not flagged as stale, but file did change.
+      // Either by disk faults (bad) or file has been changed w/o updating mtime (not so bad)
+      // Example: Office 2003 is known to update Excel files even when they are not saved
+      // Office 2003 does update an internal atime in the excel file w/o updating file's mtime
+      if (x->crc_with_xattr)
+      {
+        crc_src = CalculateCRC64(src_name);
+
+        // initially, there was a crc mismath based on stored crc in xattr. We have re-calculated the source crc
+        if (crc_des == crc_src)
+        {
+          textcolor(BRIGHT,YELLOW,BLACK);
+          printf("\nSRC == DES; But, stored CRC of SRC file does not match actual CRC of SRC file\n");
+
+          // setting to false ensures that when called from crcmv, SRC will not be removed
+          return_val = false;
+        }
+        else
+        {
+          printf(":Checksum FAILED\n");
+          return_val = false;
+        }
+      }
+      else
+      {
+        printf(":Checksum FAILED\n");
+        return_val = false;
+      }
+    }
+    else if (x->verbose)
+    {
+      char* szCRC;
+      int   ret;
+      ret = asprintf(&szCRC, "%016llX", crc_des);
+
+      if ( ret != -1)
+      {
+        textcolor(BRIGHT,GREEN,BLACK);
+        printf("[%s]\n", szCRC);
+      }
+    }
+    RESET_TEXT();
+
+    // check if crc is stored in DES xattr (as SRC might be read only)
+    if ( return_val == true && x->crc_with_xattr )
+    {
+      if ( !IsFreshCRC(dst_name) ) // UPDATE CRC when stale
+      {
+        // suppress errors writing crc in destination xattr, as destination filesystem might not support xattr
+        bool bError = false;
+
+        // CRC is stale, write the already calculated crc
+        if ( !bPutCRC(dst_name, &crc_des, bError) )
+        {
+          if (x->verbose)
+          {
+            // as this is not a fatal error, mark it as yellow
+            printStatus(dst_name, "INFO: Cannot store/update destination CRC in xattr; xattr not supported on filesystem?", GREEN);
+            RESET_TEXT();
+          }
+        }
+      }
+    }
+  }
+
   free (buf_alloc);
   free (name_alloc);
   return return_val;
 }
 
 /* Return true if it's ok that the source and destination
    files are the 'same' by some measure.  The goal is to avoid
    making the 'copy' operation remove both copies of the file
    in that case, while still allowing the user to e.g., move or
    copy a regular file onto a symlink that points to it.
