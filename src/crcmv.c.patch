--- /home/ijntema/truenas/programming/securecopy/core-utils-based/V9.7.0/coreutils-9.7/src/mv.c	2025-01-07 18:31:45.000000000 +0100
+++ /home/ijntema/truenas/programming/securecopy/core-utils-based/V9.7.0/coreutils-9.7/src/crcmv.c	2025-08-14 16:12:58.382368500 +0200
@@ -28,22 +28,25 @@
 #include "backupfile.h"
 #include "copy.h"
 #include "cp-hash.h"
 #include "filenamecat.h"
 #include "remove.h"
 #include "renameatu.h"
 #include "root-dev-ino.h"
 #include "targetdir.h"
 #include "priv-set.h"
 
+/* HIJN */
+#include "crcsum.h"
+
 /* The official name of this program (e.g., no 'g' prefix).  */
-#define PROGRAM_NAME "mv"
+#define PROGRAM_NAME "crcmv"
 
 #define AUTHORS \
   proper_name ("Mike Parker"), \
   proper_name ("David MacKenzie"), \
   proper_name ("Jim Meyering")
 
 /* For long options that have no equivalent short option, use a
    non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
 enum
 {
@@ -59,20 +62,21 @@
 };
 static enum Update_type const update_type[] =
 {
   UPDATE_ALL, UPDATE_NONE, UPDATE_NONE_FAIL, UPDATE_OLDER,
 };
 ARGMATCH_VERIFY (update_type_string, update_type);
 
 static struct option const long_options[] =
 {
   {"backup", optional_argument, nullptr, 'b'},
+  {"crc", optional_argument, nullptr, 'c'},
   {"context", no_argument, nullptr, 'Z'},
   {"debug", no_argument, nullptr, DEBUG_OPTION},
   {"exchange", no_argument, nullptr, EXCHANGE_OPTION},
   {"force", no_argument, nullptr, 'f'},
   {"interactive", no_argument, nullptr, 'i'},
   {"no-clobber", no_argument, nullptr, 'n'},   /* Deprecated.  */
   {"no-copy", no_argument, nullptr, NO_COPY_OPTION},
   {"no-target-directory", no_argument, nullptr, 'T'},
   {"strip-trailing-slashes", no_argument, nullptr,
    STRIP_TRAILING_SLASHES_OPTION},
@@ -117,20 +121,22 @@
   x->preserve_all_root = false;
 }
 
 static void
 cp_option_init (struct cp_options *x)
 {
   bool selinux_enabled = (0 < is_selinux_enabled ());
 
   cp_options_default (x);
   x->copy_as_regular = false;  /* FIXME: maybe make this an option */
+  x->crc = false;
+  x->crc_with_xattr = false;
   x->reflink_mode = REFLINK_AUTO;
   x->dereference = DEREF_NEVER;
   x->unlink_dest_before_opening = false;
   x->unlink_dest_after_failed_open = false;
   x->hard_link = false;
   x->interactive = I_UNSPECIFIED;
   x->move_mode = true;
   x->install_mode = false;
   x->one_file_system = false;
   x->preserve_ownership = true;
@@ -263,20 +269,28 @@
       fputs (_("\
 Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n\
 "), stdout);
 
       emit_mandatory_arg_note ();
 
       fputs (_("\
       --backup[=CONTROL]       make a backup of each existing destination file\
 \n\
   -b                           like --backup but does not accept an argument\n\
+  -c --crc                     check whether move was successfull with checksum comparison\n\
+                                 checksum is calculated during move\n\
+                                 checksum is not stored in xattr or compared against xattr checksum\n\
+  -cx --crc=x                  use checksum stored in xattr or if not present or stale,\n\
+                                 store/update checksum in xattr of src and des\n\
+                                 See also tool <crcsum> in same secure copy package\n\
+                                 implies --preserve=all\n\
+                                 verbose flag is supported\n\
 "), stdout);
       fputs (_("\
       --debug                  explain how a file is copied.  Implies -v\n\
 "), stdout);
       fputs (_("\
       --exchange               exchange source and destination\n\
 "), stdout);
       fputs (_("\
   -f, --force                  do not prompt before overwriting\n\
   -i, --interactive            prompt before overwrite\n\
@@ -334,30 +348,58 @@
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
   atexit (close_stdin);
 
   cp_option_init (&x);
 
   /* Try to disable the ability to unlink a directory.  */
   priv_set_remove_linkdir ();
 
-  while ((c = getopt_long (argc, argv, "bfint:uvS:TZ", long_options, nullptr))
+  while ((c = getopt_long (argc, argv, "bc::fint:uvS:TZ", long_options, nullptr))
          != -1)
     {
       switch (c)
         {
         case 'b':
           make_backups = true;
           if (optarg)
             version_control_string = optarg;
           break;
+        case 'c':
+          if (optarg)
+          {
+            if ( strcmp( optarg, "x") == 0 )
+            {
+//            x.crc = false;
+//			  x.crc_with_xattr = true;
+              x.crc = true;
+			  x.crc_with_xattr = false;
+			  
+              x.preserve_mode = true;
+              x.preserve_timestamps = true;
+              x.preserve_ownership = true;
+              x.preserve_links = true;
+              x.explicit_no_preserve_mode = false;
+              if (selinux_enabled)
+                x.preserve_security_context = true;
+              x.preserve_xattr = true;
+            }
+          }
+          else
+          {
+//            x.crc = true;
+//            x.crc_with_xattr = false;
+            x.crc = false;
+            x.crc_with_xattr = true;
+          }
+          break;
         case 'f':
           x.interactive = I_ALWAYS_YES;
           break;
         case 'i':
           x.interactive = I_ASK_USER;
           break;
         case 'n':
           x.interactive = I_ALWAYS_SKIP;
           break;
         case DEBUG_OPTION:
